2023-11-05

### JOIN

#### 개념
JOIN은 SQL에서 두 개 이상의 테이블에서 관련된 데이터를 결합하기 위해 사용되는 연산입니다. JOIN을 사용하면 테이블 간의 관계를 정의하고, 관계에 기반한 새로운 결과 테이블을 생성할 수 있습니다.

#### 특징
- **결합 기준**: 두 테이블 간의 공통 속성(기본키-외래키 관계 등)에 기반하여 결합이 이루어짐.
- **결합 방식**: 내부 조인(Inner Join), 외부 조인(Left, Right, Full Outer Join), 교차 조인(Cross Join) 등 다양한 방식이 있음.
- **결합 조건**: ON절이나 USING절을 사용하여 결합 조건을 명시함.

#### 종류
1. **Inner Join**: 두 테이블의 교집합에 해당하는 데이터만 반환합니다.
2. **Left Outer Join (Left Join)**: 왼쪽 테이블의 모든 데이터와 오른쪽 테이블의 일치하는 데이터를 반환합니다. 일치하지 않는 경우, 오른쪽 테이블의 컬럼은 NULL로 채워집니다.
3. **Right Outer Join (Right Join)**: 오른쪽 테이블의 모든 데이터와 왼쪽 테이블의 일치하는 데이터를 반환합니다. 일치하지 않는 경우, 왼쪽 테이블의 컬럼은 NULL로 채워집니다.
4. **Full Outer Join (Full Join)**: 두 테이블의 전체 데이터를 반환하며, 한쪽 테이블에만 있는 데이터는 다른 쪽 테이블에서는 NULL로 표시됩니다.
5. **Cross Join**: 두 테이블 간의 모든 가능한 조합을 반환합니다.

#### 사용 결과
JOIN을 사용하여 얻은 결과는 두 테이블의 컬럼들을 결합한 새로운 결과 테이블입니다. 이 테이블은 조인 조건에 따라서 결합된 행을 포함합니다.

#### ON절
ON절은 JOIN을 수행할 때 두 테이블을 연결하는 조건을 정의합니다. 이 조건은 두 테이블 간의 관계를 명시적으로 지정합니다.

예시:
```sql
SELECT * FROM table1
INNER JOIN table2
ON table1.id = table2.foreign_id;
```

#### USING절
USING절은 ON절의 대안으로, 두 테이블에 공통적으로 존재하는 컬럼을 기준으로 JOIN을 수행합니다. USING절은 컬럼 이름이 두 테이블에서 동일할 때 사용할 수 있습니다.

예시:
```sql
SELECT * FROM table1
INNER JOIN table2
USING (common_column);
```

### Subquery

#### 개념
Subquery는 다른 SQL 쿼리문 내부에 포함된 쿼리문입니다. Subquery는 보통 단일 값을 반환하거나, 행 집합 또는 행 집합 내의 컬럼 집합을 반환할 수 있습니다.

#### 종류
1. **단일 행 Subquery**: 하나의 행만을 반환하는 쿼리.
2. **다중 행 Subquery**: 둘 이상의 행을 반환하는 쿼리.
3. **다중 컬럼 Subquery**: 둘 이상의 컬럼을 반환하는 쿼리.
4. **상호 관련 Subquery**: 외부 쿼리의 값에 의존하는 쿼리.
5. **상관 Subquery (Correlated Subquery)**: 외부 쿼리의 컬럼을 참

조하는 쿼리.

#### 사용 불가 위치
- **GROUP BY 절**: GROUP BY 절은 집합에 대한 연산을 정의하기 때문에, 각각의 행을 처리하는 Subquery를 사용할 수 없습니다.

#### JOIN과 Subquery 비교
- **성능**: JOIN과 Subquery 간의 성능은 DBMS의 최적화 엔진에 따라 다를 수 있으며, 경우에 따라 JOIN이 더 나은 성능을 보이기도 하고, Subquery가 더 나을 수도 있습니다.
- **가독성**: Subquery는 종종 더 읽기 쉽고 이해하기 쉬운 구조를 가질 수 있으나, 복잡한 로직에서는 JOIN의 사용이 더 명확할 수 있습니다.
- **유연성**: JOIN은 여러 테이블 간의 관계를 더 명확하게 표현할 수 있으며, 복잡한 데이터 구조에서의 관계를 보다 효과적으로 처리할 수 있습니다.
- **기능적 차이**: Subquery는 결과 테이블을 반환하지 않고 값을 반환할 수 있으며, 이를 통해 조건문에서 직접 사용될 수 있습니다. 반면, JOIN은 두 테이블을 결합하여 결과 테이블을 생성합니다.

각 상황에서의 최적의 접근 방법은 데이터의 양, DBMS의 최적화, 쿼리의 복잡성 등 다양한 요소를 고려해야 합니다.

### ERD (Entity-Relationship Diagram) 구성 요소

1. **Entity (엔티티)**:
   - 개념적으로 구분 가능한 데이터의 집합.
   - 일반적으로 명사로 표현되며, 실체(사람, 장소, 사물, 이벤트) 또는 개념(회원, 주문, 제품)을 나타냄.
   - 사각형으로 표시됨.

2. **Attribute (속성)**:
   - 엔티티의 특성을 나타내며, 데이터 항목의 가장 작은 논리적 단위.
   - 원, 타원 또는 사각형으로 표시됨.

3. **Relationship (관계)**:
   - 엔티티 간의 연관성이나 상호 작용을 나타냄.
   - 일대일(1:1), 일대다(1:M), 다대다(N:M) 관계를 가질 수 있음.
   - 마름모로 표시되며, 엔티티들을 선으로 연결해 나타냄.

4. **Primary Key (기본 키)**:
   - 엔티티 내에서 각 인스턴스를 고유하게 식별하는 속성.
   - 보통 밑줄로 표시됨.

5. **Foreign Key (외래 키)**:
   - 다른 엔티티의 기본 키를 참조하는 속성으로 관계를 나타냄.

6. **Cardinality (기수)**:
   - 관계에 참여하는 엔티티들 사이의 관계 수를 나타냄.

### 모델링 구현 단계

1. **요구사항 분석**:
   - 시스템의 목적과 사용자의 요구사항을 이해하고 문서화하는 과정.

2. **개념적 설계**:
   - ERD를 사용하여 데이터와 이들 간의 관계를 고수준에서 표현.

3. **논리적 설계**:
   - 개념적 모델을 바탕으로 특정 데이터베이스 관리 시스템(DBMS)에서 사용될 수 있는 모델로 변환.
   - 데이터베이스 스키마 정의, 테이블, 키, 인덱스 생성 등의 과정 포함.

4. **물리적 설계**:
   - 논리적 데이터 모델을 실제 데이터베이스에 구현하는 단계.
   - 저장 구조, 접근 방법 결정, 성능 튜닝을 포함.

### 매핑 규칙

1. **엔티티**:
   - 엔티티는 테이블로 변환됨.
   - 엔티티의 속성은 테이블의 컬럼이 됨.
   - 엔티티의 기본 키는 테이블의 기본 키가 됨.

2. **관계**:
   - 일대일 관계: 양쪽 엔티티 중 하나에 외래 키를 추가하거나, 별도의 테이블을 생성할 수 있음.
   - 일대다 관계: '다' 쪽 엔티티에 '일' 쪽 엔티티의 기본 키를 외래 키로 추가.
   - 다대다 관계: 별도의 관계 테이블을 생성하고, 두 엔티티의 기본 키를 포함하여 외래 키로 사용.

### 정규화



정규화는 데이터베이스의 설계를 시스템적으로 진행하여 중복을 최소화하고, 데이터의 무결성과 일관성을 유지하기 위한 과정입니다.

1. **1NF (첫 번째 정규형)**:
   - 각 컬럼의 값이 원자값(분할 불가능)이 되도록 함.

2. **2NF (두 번째 정규형)**:
   - 1NF를 만족하며, 모든 비기본 키 속성이 기본 키에 완전 함수적 종속을 만족해야 함.

3. **3NF (세 번째 정규형)**:
   - 2NF를 만족하며, 모든 비기본 키 속성이 기본 키에만 의존(이행적 종속 제거).

4. **BCNF (Boyce-Codd 정규형)**:
   - 3NF를 만족하며, 모든 결정자가 후보 키가 되도록 함.

정규화의 추가 단계들은 특정 상황에서만 적용되며, 각 단계는 이전 단계를 기반으로 더욱 정교한 데이터 구조를 만들어 더 적은 데이터 중복과 높은 데이터 무결성을 보장합니다.