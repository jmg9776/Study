2023-10-31

### 1. SQL 튜닝이란
SQL 튜닝은 데이터베이스 성능을 최적화 하는 프로세스에요. 적절한 인덱스 사용, 쿼리의 개선, 서버의 설정의 조절 등 다양한 방법으로 데이터 조회 속도를 높이는 것이 주 목표입니다.

### 2. INDEX
1. 인덱스는 도서관에서 색인을 하는 것과 같아요. 데이터를 빠르게 찾을 수 있게 도와주는 역할을 합니다.
2. 인덱스는 B-tree, Bitmap, Hash등 다양한 인덱스 구조가 있어요.
	1. B-Tree
		* 구조 : 균형잡힌 트리 구조로, 가장 일반적으로 사용되는 구조입니다. 루트, 내부노드, 리프 노드로 구성됩니다.
		* 특징 :
			* 모든 리프노드는 동일한 깊이를 가져요.
			* 데이터는 리프노드에 저장되며, 리프 노드들은 링크드 리스트로 연결되어 있어요.
			* 키 값의 삽입, 삭제 시 균형을 유지해요.
		* 사용 : 대부분의 OLTP(실시간 트렌젝션 처리 시스템 Online Transaction Processing) 시스템, 범위 검색, 단일 키 검색 등에 적합해요.
	2. 비트맵 인덱스
		* 구조 : 각 키 값에 대해 비트 배열을 사용하는 인덱스 방식이에요.
		* 특징 :
			* 주로 낮은 카디널리티가 적은 데이터에 효과적이에요. 
			1. 낮은 카디널리티
				* 한 컬럼 내에 동일한 값이 많이 반복돼요.
				* 성별이나 국가와 같은 컬럼이 해당
			2. 높은 카디널리티
				* 한 컬럼 내의 대부분의 값이 고유해요.
				* 주민등록번호, 메일 주소
		* 적용 고려 :
			* 고유값에 대한 비트맵을 만들기 때문에 낮은 카디널리티에 효율적이에요. 예를 들어, 성별 컬럼에서 '남성'에 해당하는 모든 행을 표시하는 비트맵과 '여성'에 해당하는 모든 행을 표시하는 비트맵을 갖게 되는 것이죠.
	3. 해시 인덱스 :
		* 구조 : 해시 함수를 통해 변환된 주소를 사용해 데이터를 저장하고 검색하는 인덱스 방식이에요.
		* 특징 :
			* 키 값이 분포가 고르면 매우 빠른 검색 성능을 보여요.
			* 범위 검색이나 정렬된 데이터를 가져오는데 적합하지 않아요.
			* 해시 충돌이 발생할 경우 추가적인 처리가 필요해요 -> 링크드 리스트로 이어져있어 검색하는데 오버헤드가 발생해요.
				* 예를 들어서, A와 B라는 두 키 값이 같은 버킷 주소로 해싱된다면, 해당 버킷의 연결 리스트에 A를 먼저 저장하고, 그 다음 노드로 B를 저장하게 될 거예요.
		* 적용 고려 :
			* 특정 키 값을 바탕으로 빠르게 데이터를 검색하거나 수정해야 하는 경우에 유용하게 사용돼요.
* [트렌젝션 프로세싱](트렌젝션%20프로세싱.md)

### 3. 기본 원칙
- **쿼리 간소화**: 필요한 데이터만 조회하도록 쿼리를 작성해야 해요. SELECT * 대신 필요한 컬럼만 명시적으로 선택해요.
	 * ***`SELECT *`와 필요한 컬럼만 선택하는 경우의 성능 차이 이유**
	* ***데이터 전송량**: `SELECT *`를 사용하면 테이블의 모든 컬럼 데이터를 데이터베이스에서 애플리케이션 서버로 전송해야 해요. 반면 필요한 컬럼만 선택하면 전송해야 하는 데이터의 크기가 줄어들어 네트워크 부하와 데이터 전송 시간이 줄어들게 됩니다.
	* ***I/O 부하**: 모든 컬럼 데이터를 읽어야 하므로 디스크 I/O가 증가합니다. 필요한 컬럼만 조회하면 디스크에서 읽는 데이터량이 줄어들게 됩니다. 
	* ***메모리 사용량**: 데이터베이스는 쿼리 결과를 메모리에 저장하게 되는데, `SELECT *`를 사용하면 불필요한 데이터까지 메모리를 사용하게 됩니다. 이는 다른 중요한 연산에 사용되는 메모리를 줄이게 됩니다.
- **효율적인 조인 전략**: 가능한 한 조인의 수를 줄이고, 필요한 테이블만 조인해요.

### 4. 조인 전략
- **조인 순서**: 작은 테이블부터 큰 테이블로 조인하는 것이 좋아요.
- **조인 방식**: 가능한 한 내부 조인을 사용하며, 외부 조인은 필요할 때만 사용해요.
-> 작은 순서로 사용해야 처리량이 줄어들어요.

내부 조인을 선호하는 이유:
1. **성능 이슈**: 외부 조인은 NULL 값을 처리해야 하므로 내부 조인보다 더 많은 처리가 필요합니다. 이로 인해 성능이 저하될 수 있습니다.
2. **결과의 정확성**: 내부 조인은 일치하는 데이터만 반환하기 때문에 불필요한 데이터나 잘못된 데이터가 결과에 포함될 확률이 적습니다. 반면 외부 조인은 일치하지 않는 데이터에 대해 NULL 값을 반환하므로 결과에 불필요한 행이 포함될 수 있습니다.
    
3. **간결성**: 내부 조인을 사용하면 결과 세트가 더 간결하고 읽기 쉬워집니다. 외부 조인을 사용하면 결과에 NULL 값이 포함될 수 있으므로 결과를 해석하는 데 추가적인 주의가 필요합니다.
    
4. **인덱스 최적화**: 내부 조인은 일반적으로 인덱스를 더 효율적으로 사용합니다. 따라서 적절한 인덱스가 있을 경우 내부 조인은 외부 조인보다 더 빠르게 실행될 수 있습니다.
### 5. **집계 및 서브쿼리 최적화**
- **GROUP BY 최적화**: 집계 전에 WHERE절을 통해 데이터를 필터링해요.
- **서브쿼리 vs 조인**: 가능한 한 조인을 사용하되, 성능에 따라 서브쿼리 사용을 고려해요.
### **6. 데이터베이스 통계 및 옵티마이저 힌트**
- **통계 정보 최신화**: 통계 정보를 정기적으로 업데이트해서 옵티마이저가 최적의 실행 계획을 선택하도록 도와줘요.
- **옵티마이저 힌트 사용**: SQL 쿼리 성능을 더 개선하기 위해 특정 실행 계획을 강제로 사용하도록 옵티마이저에게 힌트를 주기도 해요.

### 7. 실행계획
1. **생성 과정**:
    - 사용자가 SQL 쿼리를 제출하면, 데이터베이스의 쿼리 최적화기(Query Optimizer)는 여러 가능한 실행 방법을 고려합니다.
    - 각 방법의 비용을 평가하고, 가장 효율적인 방법을 선택합니다. 이 선택된 방법이 실행계획이에요.
2. **계획의 구성 요소**:
    - **연산자(Operators)**: 쿼리 실행에 필요한 작업들을 나타냅니다. 예를 들면, 테이블 스캔, 인덱스 스캔, 조인, 필터링 등이 있어요.
    - **데이터 구조** : 사용될 테이블, 인덱스, 뷰 등의 정보를 포함합니다.
    - **순서** : 연산자와 데이터 구조를 어떤 순서로 처리할지 결정합니다.
3. **비용 기반 최적화**:
    - 데이터베이스는 실행계획을 선택할 때 일반적으로 "비용 기반 최적화" 방법을 사용합니다.
    - 이는 각 계획의 비용을 계산하고, 가장 낮은 비용을 가진 계획을 선택합니다. 비용은 CPU 사용량, I/O, 네트워크 전송 시간 등을 고려하여 계산됩니다.
4. **계획의 중요성**:
    - 효율적인 실행계획은 데이터베이스 성능에 큰 영향을 미칩니다. 좋은 실행계획은 쿼리 성능을 크게 향상시킬 수 있어요.
    - 반대로, 비효율적인 실행계획은 성능 저하의 주요 원인이 될 수 있습니다.
5. **실행계획 확인**:
    - 대부분의 데이터베이스 관리 시스템(DBMS)에서는 사용자가 실행계획을 확인할 수 있는 도구나 명령어를 제공합니다. 예를 들면, Oracle의 `EXPLAIN PLAN`이나 SQL Server의 `Query Execution Plan` 도구가 있습니다.
    - 이를 통해 쿼리의 성능 문제를 진단하고 최적화할 수 있습니다.
### **예시:**

**원본 쿼리**:
`SELECT * FROM employees e, departments d WHERE e.department_id = d.department_id;`

**튜닝 후 쿼리**:
`SELECT e.first_name, e.last_name, d.department_name  FROM employees e  INNER JOIN departments d ON e.department_id = d.department_id  WHERE e.salary > 5000;`